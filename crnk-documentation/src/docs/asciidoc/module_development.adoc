
# Module Development

Crnk has a module API that allows to extend the core functionality by third-party contributions.
The mentioned JPA module in the next section is an example for that. The API is similar in spirit
to the one of the `https://github.com/FasterXML/jackson`. The main interface is `Module` with
a default implementation provided by `SimpleModule`. A module has access to a `ModuleContext`
that allows to register all kinds of extensions like new `ResourceInformationBuilder`,
`ResourceLookup`, `Filter`, `ExceptionMapper` and Jackson modules. It also gives access to the
`ResourceRegistry` holding information about all the repositories registered to crnk.
The `JpaModule` in `crnk-jpa` provides a good, more advanced example of using the
module API.



## Request Filtering

Crnk provides three different, complementing mechanisms to hook into the request processing.

The `DocumentFilter` interface allows to intercept incoming requests and do
any kind of validation, changes, monitoring, transaction handling, etc. `DocumentFilter` can be
hooked into Crnk by setting up a module and registering the filter to the
`ModuleContext`. Not that for every request, this interface is called exactly once.

A request may span multiple repository accesses. To intercept the actual repository requests,
implement the `RepositoryFilter` interface. `RepositoryFilter` has a number of methods
that allow two intercept the repository request at different stages. Like `Filter` it can be
hooked into Crnk by setting up a module and registering the filter to the
`ModuleContext`.

Similar to `RepositoryFilter` it is possible to decorate a repository with another repository
implementing the same Crnk repository interfaces. The decorated repository instead of
the actual repository will get called and it is up to the decorated repository of how to proceed
with the request, usually by calling the actual repository. `RepositoryDecoratorFactory`
can be registered with `ModuleContext.addRepositoryDecoratorFactory`. The factory gets
notified about every repository registration and is then free do decorate it or not.


## Integrate third-party data stores

The core of Crnk is quite flexible when it comes to implementing repositories. As such, it is
not mandatory to make use of the Crnk annotations and conventions. Instead, it is also
(likely) possible to integrate an existing data store setup like JPA, JDBC, ElasticSearch, etc.
into Crnk. For this purpose a module can provide custom implementations of
`ResourceInformationBuilder` and `RepositoryInformationBuilder` trough
`ModuleContext.addResourceInformationBuilder` and `ModuleContext.addRepositoryInformationBuilder`.
For example, the JpaModule of  `crnk-jpa` makes use of that to read JPA instead of Crnk annotations.
Such a module can then register additional (usually dynamic) repositories with
`ModuleContext.addRepository`.


## Implement a custom discovery mechanism

Crnk comes with out-of-the-box support for Spring and CDI. Both of them implement
`ServiceDiscovery`. You may provide your own implementation which can be hooked into the
various Crnk integrations, like the CrnkFeature. Modules have access to that
`ServiceDiscovery` trough the `ModuleContext`.


## Let a module hook into the Crnk HTTP client implementation

Modules for the Crnk client can additionally implement `HttpAdapterAware`. It gives
the module access to the underlying HTTP client implementation and allows arbitrary
customizations of it. Have a look at the Crnk client documentation for more information.

## Implement a custom integration

Adding a new integration has become quite simple in recent times.
Have a look at `crnk-servlet` and `crnk-rs`. Most functionality
necessary is already be provided by `crnk-core`. The steps include:

- implement `HttpRequestContextBase`.
- instantiate `CrnkBoot` to setup crnk.
- get the `RequestDispatcher` from `CrnkBoot`.
- invoke the `RequestDispatcher` for each incoming request with the implemented
  `HttpRequestContextBase`.
- you may want to further implement `SecurityProvider`, `TransactionRunner`
  and `PropertiesProvider` to interface with that particular systems.


## Create repositories at runtime

Repositories are usually created at compile-time, either by making use of the various annotations or a module
such as the ´JpaModule´. However, the module API also allows the creation of repositories at runtime.
There are two complementary mechanisms in place to achieve this and outlined in the next two sections.


### Implementing repositories dynamically at runtime

A repository is implemented by providing a repository implementation and information about it. Information
includes, most importantly, naming and a list of attributes. Such information
is provided by a ´RepositoryInformationBuilder´:

[source]
.DynamicResourceRepositoryInformationBuilder.java
----
include::../../../../crnk-client/src/test/java/io/crnk/client/dynamic/DynamicResourceRepositoryInformationBuilder.java[tags=docs]
----

Since attributes are determined at runtime, usually no class will be present to represent that resource.
In such cases there are three possibilities:

- Create a matching resource class at runtime with a library like http://bytebuddy.net/#/ to follow the same
  pattern as for any compile-time repository.
- Make use of the `Resource` class. It is the JSON API resource presentation within the Crnk engine.
- Make use of an arbitrary dynamic object like a `java.util.Map` and provide a `ResourceFieldAccessor` for
  each `ResourceField` to specify how to read and write attributes.

In the following example we make use of the second option:

[source]
.DynamicResourceRepository.java
----
include::../../../../crnk-client/src/test/java/io/crnk/client/dynamic/DynamicResourceRepository.java[tags=docs1]
...
include::../../../../crnk-client/src/test/java/io/crnk/client/dynamic/DynamicResourceRepository.java[tags=docs2]
----

Finally the implemented code can be registered with a Module to Crnk:

[source]
.DynamicModule
----
include::../../../../crnk-client/src/test/java/io/crnk/client/dynamic/DynamicModule.java[tags=docs]
----

Have a look at the complete example
in https://github.com/crnk-project/crnk-framework/tree/master/crnk-client/src/main/java/io/crnk/client/dynamic[`crnk-client`].
There is a further example test case and relationship repository.

### Registering repositories at runtime

There are two possibilities to register a new repository at runtime:

- by using a `Module` and invoking `ModuleContext.addRepository` as done in the previous section.
- by implementing a `ResourceRegistryPart` and invoking `ModuleContext.addResourceRegistry`.

The first is well suited if there is a predefined set of repositories that need to be registered
(like a fixed set of JPA entities in the `JpaModule`). The later is suited for fully dynamic use cases where
the set of repositories can change over time (like tables in a database or tasks in an activiti instance). In this
case the repositories no longer need registration. Instead the custom `ResourceRegistryPart` implementation always
provides an up-to-date set of repositories that is used by the Crnk engine.








